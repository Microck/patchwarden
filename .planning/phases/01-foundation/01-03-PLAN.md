---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/jarspect/models/__init__.py
  - src/jarspect/models/intake.py
  - src/jarspect/analysis/__init__.py
  - src/jarspect/analysis/jar_extract.py
  - src/jarspect/agents/__init__.py
  - src/jarspect/agents/intake_agent.py
  - src/jarspect/api/routes/scan.py
  - src/jarspect/api/main.py
  - tests/test_intake.py
autonomous: true

must_haves:
  truths:
    - "Given an upload_id, the service extracts jar metadata"
    - "Service detects Minecraft mod loader type (fabric/forge/unknown)"
  artifacts:
    - path: "src/jarspect/agents/intake_agent.py"
      provides: "Intake agent"
    - path: "src/jarspect/analysis/jar_extract.py"
      provides: "Safe jar extraction + inspection"
  key_links:
    - from: "src/jarspect/api/routes/scan.py"
      to: "src/jarspect/agents/intake_agent.py"
      via: "run_intake(upload_id)"
      pattern: "IntakeAgent"
---

<objective>
Add the Intake Agent that extracts `.jar` contents safely and identifies mod type / loader hints.

Purpose: Provide normalized inputs for downstream analysis agents.
Output: POST /scan (intake-only) producing structured intake results.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Jar extraction + mod type detection utilities</name>
  <files>
src/jarspect/models/__init__.py
src/jarspect/models/intake.py
src/jarspect/analysis/__init__.py
src/jarspect/analysis/jar_extract.py
  </files>
  <action>
Implement safe `.jar` inspection utilities:
- Treat jar as zip; validate entries to prevent zip-slip path traversal.
- Extract to a temp dir (or stream-inspect) and return:
  - list of file paths inside jar (bounded; avoid loading huge lists)
  - presence of key mod metadata files:
    - `fabric.mod.json` => loader `fabric`
    - `META-INF/mods.toml` => loader `forge`
    - `mcmod.info` (legacy) => loader `forge_legacy`
    - fallback: `unknown`
  - `manifest` basic attributes if present.

Define Pydantic models in `src/jarspect/models/intake.py` for `IntakeResult` including:
- `upload_id`, `filename`
- `mod_type` (for MVP: always `minecraft_jar` when `.jar`)
- `loader` (fabric/forge/forge_legacy/unknown)
- `file_count`, `top_level_entries` (bounded list)
  </action>
  <verify>python3 -m pytest -q -k intake --maxfail=1</verify>
  <done>Intake models exist and jar inspection code handles path traversal safely.</done>
</task>

<task type="auto">
  <name>Task 2: Intake agent + scan endpoint</name>
  <files>
src/jarspect/agents/__init__.py
src/jarspect/agents/intake_agent.py
src/jarspect/api/routes/scan.py
src/jarspect/api/main.py
tests/test_intake.py
  </files>
  <action>
Create `IntakeAgent` that:
- Fetches uploaded bytes via the configured storage backend
- Runs jar inspection
- Returns `IntakeResult`

Add `POST /scan` taking JSON `{upload_id}` and returning `{intake: IntakeResult}` for now (later phases will extend it).

Tests:
- Upload a fake `.jar` (use zipfile in test to include `fabric.mod.json`) then scan and assert loader is `fabric`.
- Provide a second fixture with `META-INF/mods.toml` and assert loader is `forge`.
  </action>
  <verify>python3 -m pytest -q</verify>
  <done>`POST /scan` returns intake results derived from stored upload bytes.</done>
</task>

</tasks>

<verification>
- Start server; `POST /upload` then `POST /scan` returns detected loader
- Tests cover at least fabric + forge detection
</verification>

<success_criteria>
- Phase 1 end-to-end: upload -> intake scan works with local storage
- Intake result is structured and ready for static agent consumption
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
