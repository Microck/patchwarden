---
phase: 02-static-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/jarspect/analysis/decompiler.py
  - src/jarspect/analysis/jar_classes.py
  - src/jarspect/analysis/tempdirs.py
  - tests/test_decompiler.py
autonomous: true

must_haves:
  truths:
    - "Service can enumerate .class files from an uploaded jar"
    - "Service can produce readable source-like text for classes (via decompiler or fallback)"
  artifacts:
    - path: "src/jarspect/analysis/decompiler.py"
      provides: "Decompilation wrapper"
    - path: "src/jarspect/analysis/jar_classes.py"
      provides: "Class enumeration/extraction"
  key_links:
    - from: "src/jarspect/analysis/decompiler.py"
      to: "java subprocess"
      via: "CFR jar invocation"
      pattern: "subprocess"
---

<objective>
Create a static decompilation layer that can turn jar bytecode into text for downstream pattern matching.

Purpose: Enable Static Agent to analyze Java code without executing it.
Output: Jar class enumeration + decompiler wrapper + tests.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enumerate and extract class files safely</name>
  <files>
src/jarspect/analysis/jar_classes.py
src/jarspect/analysis/tempdirs.py
  </files>
  <action>
Implement utilities that:
- List `.class` entries inside the jar (bounded; avoid unbounded memory)
- Extract selected entries to a temporary directory
- Reuse the same zip-slip protections as intake extraction

`src/jarspect/analysis/tempdirs.py` should provide a small helper for managed temp dirs for analysis runs.
  </action>
  <verify>python3 -m pytest -q -k decompiler --maxfail=1</verify>
  <done>Class listing/extraction works on a synthetic jar built in tests.</done>
</task>

<task type="auto">
  <name>Task 2: Decompiler wrapper with env-gated external tool</name>
  <files>
src/jarspect/analysis/decompiler.py
tests/test_decompiler.py
  </files>
  <action>
Implement a `Decompiler` interface with a default behavior that works without downloads:
- Fallback: run `javap -c` (if available) to produce disassembly-like text.

Add optional support for a real decompiler via an env var:
- If `CFR_JAR_PATH` is set, run `java -jar $CFR_JAR_PATH` to decompile class files to Java-like source.
- If unset, use the fallback.

Tests should:
- Build a tiny jar in-test (compile a small Java class) OR include a minimal prebuilt class bytes in fixtures.
- Assert that decompile output contains at least the class name and method name using fallback mode.

Note: Do not auto-download tools in library code; keep execution deterministic.
  </action>
  <verify>python3 -m pytest -q</verify>
  <done>Decompiler returns readable text in fallback mode; CFR path enables better output when configured.</done>
</task>

</tasks>

<verification>
- `python3 -m pytest -q` passes
- If CFR is configured: a manual run shows Java-like decompilation output
</verification>

<success_criteria>
- Static analysis can obtain consistent text from jars without executing code
</success_criteria>

<output>
After completion, create `.planning/phases/02-static-analysis/02-01-SUMMARY.md`
</output>
