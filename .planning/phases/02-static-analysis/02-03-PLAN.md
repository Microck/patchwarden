---
phase: 02-static-analysis
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - data/signatures/signatures.json
  - src/jarspect/signatures/__init__.py
  - src/jarspect/signatures/store.py
  - src/jarspect/signatures/local_json.py
  - src/jarspect/signatures/azure_search.py
  - scripts/signatures_index.py
  - tests/test_signatures.py
autonomous: true

must_haves:
  truths:
    - "Signature lookup returns matches for known suspicious tokens"
    - "Signature store runs locally without Azure configuration"
  artifacts:
    - path: "data/signatures/signatures.json"
      provides: "Benign signature corpus for demo"
    - path: "src/jarspect/signatures/store.py"
      provides: "Signature store interface"
  key_links:
    - from: "src/jarspect/signatures/local_json.py"
      to: "data/signatures/signatures.json"
      via: "load"
      pattern: "signatures.json"
---

<objective>
Add a signature database abstraction with a local JSON-backed implementation and an optional Azure AI Search adapter.

Purpose: Support known-bad (or known-suspicious) token matching in static analysis without requiring external services for local development.
Output: Signature store + sample signatures + tests + optional indexing script.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add safe signature corpus for MVP</name>
  <files>data/signatures/signatures.json</files>
  <action>
Create `data/signatures/signatures.json` containing a small set of SAFE, synthetic signatures suitable for a hackathon demo.

Do NOT include real malware samples, binaries, or exploit code.
Allowed examples:
- suspicious domain strings (non-resolving test domains)
- method/class tokens often used in droppers (names only)
- obfuscation markers (e.g., repeated base64 decode)

Include fields per signature:
- `id`, `kind` (token/regex), `value`, `severity`, `description`
  </action>
  <verify>python3 -c "import json; d=json.load(open('data/signatures/signatures.json')); assert isinstance(d, list) and len(d) >= 5"</verify>
  <done>Signature corpus exists and contains at least 5 entries with IDs and severities.</done>
</task>

<task type="auto">
  <name>Task 2: Signature store interface + local JSON implementation</name>
  <files>
src/jarspect/signatures/__init__.py
src/jarspect/signatures/store.py
src/jarspect/signatures/local_json.py
tests/test_signatures.py
  </files>
  <action>
Implement a `SignatureStore` interface with:
- `search(text: str) -> list[SignatureMatch]`

Implement `LocalJsonSignatureStore` that loads `data/signatures/signatures.json` and returns matches with evidence offsets/snippets.

Tests should assert:
- known token appears in text -> match returned
- text without tokens -> empty list
  </action>
  <verify>python3 -m pytest -q -k signatures --maxfail=1</verify>
  <done>Local signature searching works and is tested.</done>
</task>

<task type="auto">
  <name>Task 3: Optional Azure AI Search adapter + indexing script</name>
  <files>
src/jarspect/signatures/azure_search.py
scripts/signatures_index.py
  </files>
  <action>
Implement `AzureSearchSignatureStore` behind env gating.

Expected env vars (document in code, do not require by default):
- `AZURE_SEARCH_ENDPOINT`
- `AZURE_SEARCH_API_KEY`
- `AZURE_SEARCH_INDEX`

Provide `scripts/signatures_index.py` that reads the local JSON signatures and indexes them into Azure AI Search when configured.
The script should be safe to run multiple times (idempotent by signature id).
  </action>
  <verify>python3 -c "from jarspect.signatures.local_json import LocalJsonSignatureStore; LocalJsonSignatureStore()"</verify>
  <done>Local signature store remains the default; Azure adapter exists but is optional.</done>
</task>

</tasks>

<verification>
- `python3 -m pytest -q` passes
- Local signature matching works without Azure env vars
</verification>

<success_criteria>
- The project has a signature lookup capability that does not require external services
- Optional Azure indexing path exists for hackathon environments
</success_criteria>

<output>
After completion, create `.planning/phases/02-static-analysis/02-03-SUMMARY.md`
</output>
